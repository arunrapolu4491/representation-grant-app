
var path = require("path");
var BuiltinModule = require("module");
global.XMLHttpRequest = require('xhr2');

XMLHttpRequest.prototype.send = function(body) {
  return "";
};

//Resolve our vue files with a blank.ts, this will allow the code to execute.
var Module = module.constructor.length > 1 ? module.constructor : BuiltinModule;
var oldResolveFilename = Module._resolveFilename;
Module._resolveFilename = function(request, parentModule, isMain, options) {
  if (request.includes(".vue")) return "blank.ts";
  if (request.includes("@")) return path.join(__dirname, request.replace("@/", "../src/") + ".js");
  return oldResolveFilename.call(this, request, parentModule, isMain, options);
};

import { readFileSync, writeFileSync, unlinkSync } from "fs";
const filePath = path.join(__dirname, "../../../src/types/survey-primary.ts");

import * as Survey from "survey-vue";

import { addQuestionTypes } from "../src/survey/question-types/question-types";
const json = readFileSync("../src/survey-primary.json").toString();

const generateQuestionNamesEnum = survey => {
  console.log('Generating Question Names Enum..');
  let questionNames = [];
  let data = `// This is autogenerated by tools/gen_typescript_response. on ${new Date().toISOString()} \n`;
  data += `export enum SurveyQuestionNames {\n`;
  survey.getAllQuestions(false, true).forEach(function(question) {
    if (questionNames.includes(question.name)) {
      console.log(`Warning: Found duplicate questionName: ${question.name}. Skipping.`);
      return;
    }
    if (question.name.includes("?") || question.name.includes("-"))
      data += `\t\"${question.name}\" = \"${question.name}\",\n`;
    else data += `\t${question.name} = \"${question.name}\",\n`;
    questionNames.push(question.name);
  });
  data += "}\n";
  writeFileSync(filePath, data, { encoding: "utf8", flag: "w" });
};

//TODO we have seperated interfaces, lets NEST them. 
const generateQuestionInterfaces = survey => {
  console.log('Generating Interfaces..');
  const panelQuestionNames = [];
  let data = '//Generated interfaces here.\n';
  survey.getAllQuestions(false, true).filter(x => x.getType() === "paneldynamic").forEach(function(question) {
    if (question?.panels[0] == null || question.panels[0].questions.length == 0)
      return;
    panelQuestionNames.push(question.name);
    data += `export interface ${question.name} {\n`;
    const questions = question?.panels[0].questions;
    for (let i = 0; i < questions.length; i++) { 
      panelQuestionNames.push(questions[i].name);
      if (questions[i].name.includes("?") || questions[i].name.includes("-"))
      data += `\t\"${questions[i].name}\"?: string,\n`;
      else data += `\t${questions[i].name}?: string\n`;
    }
    data += "}\n";
  })

  data += `export interface SurveyInstance {\n`;
  survey.getAllQuestions(false, true).filter(x => x.getType() !== "paneldynamic").forEach(function(question) {
    if (panelQuestionNames.includes(question.name))
      return;
    if (question.name.includes("?") || question.name.includes("-"))
      data += `\t\"${question.name}\"?: string,\n`;
      else data += `\t${question.name}?: string\n`;
  })
  data += "}\n";
  writeFileSync(filePath, data, { encoding: "utf8", flag: "a" });
}

export const generateSurveyModels = () => {
  addQuestionTypes(Survey);
  const survey = new Survey.SurveyModel(json);
  console.log(`Generating response, writing to file ${filePath}`);
  generateQuestionNamesEnum(survey);
  generateQuestionInterfaces(survey);
};

generateSurveyModels();
